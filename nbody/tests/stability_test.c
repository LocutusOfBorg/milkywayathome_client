/* This program tests the stability of a 2-component dwarf galaxy.
* Dwarf galaxy types tested in this program:
* 1. Plummer-Plummer
* Stability is determined by Kullback-Leibler divergence calculation of the theoretical probability density distribution
* and the normalized density distribution generated by MilkyWay@home.  
* Since the distribution of baryons and dark matter are determined separately, the program calculates the KL divergence for each component.
* If unstable, the generated density distribution tends to oscillate from looking stable to unstable.
* Because of this, the program calculates the KL divergence for each component at multiple time steps as to not accidentally conclude that an unstable system is stable.
*/

/* TODO:
* Change the lua file to use the get_soft_par() function to get the softening parameter instead of a hard coded value.
* Add NFW profile test.
* Add cored profile test.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include "nbody_particle_data.h"
#include "test_env_util.h"

/* Dwarf galaxy parameters */
#define EVOLUTION_TIME "2.0"                  /* Evolution time in Gyr */
#define EVOLUTION_RATIO "0.0"                 /* Evolution time ratio */
#define BARYON_SCALE_RADIUS "0.181216"        /* Baryon Scale radius in kpc */
#define SCALE_RADIUS_RATIO "0.182799"         /* Scale radius ratio */
#define BARYON_MASS "1.22251"                 /* Baryon Mass in SMU */
#define MASS_RATIO "0.0126171"                /* Mass ratio */

/* KL divergence thresholds */
#define INITIAL_KL_THRESHOLD 0.01   /* Maximum acceptable initial KL divergence */
#define KL_FLUCTUATION_THRESHOLD 0.005 /* Maximum acceptable KL divergence fluctuation */

/* Maximum path length */
#define MAX_PATH_LENGTH 1024

/**
 * @brief Clean up all allocated memory
 */
static void cleanup_all_memory(
    char* input_lua_file,
    real* baryon_bin_centers, real* dark_bin_centers,
    real* baryon_bin_edges, real* dark_bin_edges,
    real* baryon_theoretical_density, real* dark_theoretical_density,
    real* baryon_theoretical_probability, real* dark_theoretical_probability,
    real* baryon_simulation_density, real* dark_simulation_density,
    real* baryon_simulation_probability, real* dark_simulation_probability,
    ParticleCollection* particle_data
) {
    // Free all memory - safe to call with NULL pointers
    free(input_lua_file);
    free(baryon_bin_centers);
    free(dark_bin_centers);
    free(baryon_bin_edges);
    free(dark_bin_edges);
    free(baryon_theoretical_density);
    free(dark_theoretical_density);
    free(baryon_theoretical_probability);
    free(dark_theoretical_probability);
    free(baryon_simulation_density);
    free(dark_simulation_density);
    free(baryon_simulation_probability);
    free(dark_simulation_probability);
    
    if (particle_data) {
        free_particle_collection(particle_data);
    }
}

/**
 * @brief Calculate the mass enclosed within a given radius for a dwarf component
 * 
 * @param comp The dwarf component
 * @param radius The radius to calculate mass within
 * @return real The enclosed mass
 */
static real mass_enclosed_function(const Dwarf *comp, real radius) {
    if (comp == NULL) {
        fprintf(stderr, "Error: Null dwarf component in mass_enclosed_function\n");
        return 0.0;
    }
    return 4.0 * M_PI * sqr(radius) * get_density(comp, radius);
}

/**
 * @brief Calculate the expected counts per bin for a given radius
 * 
 * @param comp The dwarf component
 * @param radius The radius to calculate at
 * @param mass_per_particle Mass per particle
 * @param bin_width Width of histogram bin
 * @return real The expected counts
 */
static real counts_per_bin(const Dwarf *comp, real radius, real mass_per_particle, real bin_width) {
    if (comp == NULL || mass_per_particle <= 0.0 || bin_width <= 0.0) {
        fprintf(stderr, "Error: Invalid parameters in counts_per_bin\n");
        return 0.0;
    }
    return mass_enclosed_function(comp, radius) * (1.0 / mass_per_particle) * bin_width;
}

/**
 * @brief Smooth and normalize a density distribution into a probability distribution
 * 
 * Adds a small epsilon to avoid zeros and normalize the distribution to sum to 1.0
 * 
 * @param counts Array of counts
 * @param size Size of the array
 * @return real* Newly allocated array with normalized counts
 */
static real* smooth_and_normalize_distribution(real* counts, size_t size) {   
    if (counts == NULL || size == 0) {
        fprintf(stderr, "Error: Invalid parameters in smooth_and_normalize_distribution\n");
        return NULL;
    }
    
    real epsilon = 1e-10;
    real sum = 0.0;
    real* normalized_counts = mwCallocA(size, sizeof(real));  
    if (normalized_counts == NULL) {
        fprintf(stderr, "Error: Memory allocation failed in smooth_and_normalize_distribution\n");
        return NULL;
    }

    // Add epsilon and calculate sum
    for (size_t i = 0; i < size; i++) {
        counts[i] += epsilon;
        sum += counts[i];
    }
        
    // Normalize the counts
    for (size_t i = 0; i < size; i++) {
        normalized_counts[i] = counts[i] / sum;
    }
    return normalized_counts;
}

/**
 * @brief Calculate the Kullback-Leibler divergence between two probability distributions
 * 
 * @param p Simulation probability distribution
 * @param q Theoretical probability distribution
 * @param size Size of the distributions
 * @return real The KL divergence
 */
static real kl_divergence(const real *p, const real *q, size_t size) {
    if (p == NULL || q == NULL || size == 0) {
        fprintf(stderr, "Error: Invalid parameters in kl_divergence\n");
        return -1.0;
    }
    
    real kl_div = 0.0;
    
    for (size_t i = 0; i < size; i++) {
        if (p[i] <= 0.0 || q[i] <= 0.0) {
            fprintf(stderr, "Warning: Non-positive value in KL divergence at index %zu: p=%f, q=%f\n", 
                   i, p[i], q[i]);
            continue;
        }
        kl_div += p[i] * mw_log(p[i] / q[i]);
    }
    
    return kl_div;
}

/**
 * @brief Fucntion for the stability test for a given dwarf potential type
 * 
 * @param dwarf_potential_type The type of dwarf potential to use
 * @return int 0 on success, non-zero on failure
 */
int testStability(const char* dwarf_potential_type_lua) {
    printf("Starting stability test...\n");
    fflush(stdout);
    
    // Initialize all pointers to NULL
    char* input_lua_file = NULL;
    real* baryon_bin_centers = NULL;
    real* dark_bin_centers = NULL;
    real* baryon_bin_edges = NULL;
    real* dark_bin_edges = NULL;
    real* baryon_theoretical_density = NULL;
    real* dark_theoretical_density = NULL;
    real* baryon_theoretical_probability = NULL;
    real* dark_theoretical_probability = NULL;
    real* baryon_simulation_density = NULL;
    real* dark_simulation_density = NULL;
    real* baryon_simulation_probability = NULL;
    real* dark_simulation_probability = NULL;
    ParticleCollection* particle_data = NULL;
    
    // Initialize other variables
    real nbody = 0.0;
    real nbody_baryon = 0.0;
    real nbody_dark = 0.0;
    Dwarf *comp1 = NULL;
    Dwarf *comp2 = NULL;
    real timestep = 0.0;
    real mass_per_particle_baryon = 0.0;
    real mass_per_particle_dark = 0.0;
    real bin_width = 0.0;
    int num_bins_baryon = 0;
    int num_bins_dark = 0;
    real initial_kl_divergence_baryon = 0.0;
    real initial_kl_divergence_dark = 0.0;
    int failed = 0;

    // Initialize the dwarf parameters
    const char* dwarf_params[] = {
        EVOLUTION_TIME,
        EVOLUTION_RATIO,
        BARYON_SCALE_RADIUS,
        SCALE_RADIUS_RATIO,
        BARYON_MASS,
        MASS_RATIO
    };
    
    // Clean up any output files from previous runs
    printf("Cleaning up any output files from previous runs...\n");
    fflush(stdout);

    // Remove initial output file 
    const char* initial_output_file = "initial.out";
    if (access(initial_output_file, F_OK) != -1) {
        if (remove(initial_output_file) == 0) {
            printf("Removed old output file: %s\n", initial_output_file);
        } else {
            fprintf(stderr, "Failed to remove old output file: %s - %s\n", 
                  initial_output_file, strerror(errno));
        }
    }
    
    char output_filename[MAX_PATH_LENGTH];
    // Remove output files with numeric names (0, 1, 2, etc.)
    for (int i = 0; i < 10000; i++) {
        snprintf(output_filename, sizeof(output_filename), "%d", i);
        if (access(output_filename, F_OK) != -1) {
            if (remove(output_filename) == 0) {
                printf("Removed old output file: %s\n", output_filename);
            } else {
                fprintf(stderr, "Failed to remove old output file: %s - %s\n", 
                      output_filename, strerror(errno));
            }
        }
    }
    
    // Remove final output files
    const char* final_output_files[] = {"output.out", "output.hist"};
    for (int i = 0; i < sizeof(final_output_files) / sizeof(final_output_files[0]); i++) {
        if (access(final_output_files[i], F_OK) != -1) {
            if (remove(final_output_files[i]) == 0) {
                printf("Removed old output file: %s\n", final_output_files[i]);
            } else {
                fprintf(stderr, "Failed to remove old output file: %s - %s\n", 
                      final_output_files[i], strerror(errno));
            }
        }
    }
    printf("Cleanup complete.\n");
    fflush(stdout);

    // Find the lua file
    input_lua_file = find_lua_file(dwarf_potential_type_lua);
    if (!input_lua_file) {
        fprintf(stderr, "Error: Could not find %s.lua in any expected location\n", dwarf_potential_type_lua);
        failed = 1;
        goto cleanup;
    }
    
    printf("Input file path: %s\n", input_lua_file);
    fflush(stdout);

    // Read the parameters from the Lua file
    printf("Reading Lua parameters...\n");
    fflush(stdout);
    if (read_lua_parameters(input_lua_file, dwarf_params, &nbody, &nbody_baryon, &comp1, &comp2, &timestep, NULL) != 0) {
        fprintf(stderr, "Error: Failed to read Lua parameters\n");
        fflush(stdout);
        failed = 1;
        goto cleanup;
    }

    // Calculate the mass per particle for each component
    nbody_dark = nbody - nbody_baryon;
    if (nbody_dark <= 0) {
        fprintf(stderr, "Error: Invalid number of dark matter particles: %f\n", nbody_dark);
        failed = 1;
        goto cleanup;
    }
    
    // Validate component parameters
    if (comp1 == NULL || comp2 == NULL) {
        fprintf(stderr, "Error: Invalid dwarf components (NULL)\n");
        failed = 1;
        goto cleanup;
    }
    
    if (comp1->mass <= 0 || comp2->mass <= 0) {
        fprintf(stderr, "Error: Invalid component masses: comp1=%f, comp2=%f\n", 
               comp1->mass, comp2->mass);
        failed = 1;
        goto cleanup;
    }
    
    mass_per_particle_baryon = comp1->mass / nbody_baryon;
    mass_per_particle_dark = comp2->mass / nbody_dark;
    
    if (mass_per_particle_baryon <= 0 || mass_per_particle_dark <= 0) {
        fprintf(stderr, "Error: Invalid mass per particle: baryon=%f, dark=%f\n", 
               mass_per_particle_baryon, mass_per_particle_dark);
        failed = 1;
        goto cleanup;
    }
    
    printf("mass_per_particle_baryon: %f\n", mass_per_particle_baryon);
    printf("mass_per_particle_dark: %f\n", mass_per_particle_dark);
    fflush(stdout);

    // Calculating bin width
    if (comp1->scaleLength <= 0 || comp2->scaleLength <= 0) {
        fprintf(stderr, "Error: Invalid scale lengths: comp1=%f, comp2=%f\n", 
               comp1->scaleLength, comp2->scaleLength);
        failed = 1;
        goto cleanup;
    }
    
    bin_width = mw_fmin(comp1->scaleLength, comp2->scaleLength) / 5.0;
    if (bin_width <= 0) {
        fprintf(stderr, "Error: Invalid bin width: %f\n", bin_width);
        failed = 1;
        goto cleanup;
    }
    
    printf("Bin width: %f\n", bin_width);
    fflush(stdout);

    // Calculate number of bins needed for each component (matching np.arange)
    num_bins_baryon = (int)((4.0 * comp1->scaleLength - 0.2 * comp1->scaleLength) / bin_width) + 1;
    num_bins_dark = (int)((4.0 * comp2->scaleLength - 0.2 * comp2->scaleLength) / bin_width) + 1;
    
    if (num_bins_baryon <= 0 || num_bins_dark <= 0) {
        fprintf(stderr, "Error: Invalid number of bins: baryon=%d, dark=%d\n", 
               num_bins_baryon, num_bins_dark);
        failed = 1;
        goto cleanup;
    }

    printf("Using %d bins for baryon component and %d bins for dark matter component\n", 
           num_bins_baryon, num_bins_dark);
    fflush(stdout);

    // Creating radius arrays for KL divergence calculation for each component (bin centers)
    baryon_bin_centers = mwCallocA(num_bins_baryon, sizeof(real));
    dark_bin_centers = mwCallocA(num_bins_dark, sizeof(real));
    
    if (baryon_bin_centers == NULL || dark_bin_centers == NULL) {
        fprintf(stderr, "Error: Failed to allocate memory for radius arrays\n");
        failed = 1;
        goto cleanup;
    }

    // Create bin edges 
    baryon_bin_edges = mwCallocA(num_bins_baryon + 1, sizeof(real));
    dark_bin_edges = mwCallocA(num_bins_dark + 1, sizeof(real));
    
    if (baryon_bin_edges == NULL || dark_bin_edges == NULL) {
        fprintf(stderr, "Error: Failed to allocate memory for bin edges\n");
        failed = 1;
        goto cleanup;
    }

    // Initialize baryon bin edges
    for (int i = 0; i <= num_bins_baryon; i++) {
        baryon_bin_edges[i] = 0.2 * comp1->scaleLength + i * bin_width;
    }

    // Initialize baryon bin centers
    for (int i = 0; i < num_bins_baryon; i++) {
        baryon_bin_centers[i] = baryon_bin_edges[i] + bin_width / 2.0;
    }
    
    // Initialize dark matter bin edges
    for (int i = 0; i <= num_bins_dark; i++) {
        dark_bin_edges[i] = 0.2 * comp2->scaleLength + i * bin_width;
    }

    // Initialize dark matter bin centers
    for (int i = 0; i < num_bins_dark; i++) {
        dark_bin_centers[i] = dark_bin_edges[i] + bin_width / 2.0;
    }

    // Print the bin edges and centers
    printf("Baryon bin edges: ");
    for (int i = 0; i <= num_bins_baryon; i++) {
        printf("%.6f ", baryon_bin_edges[i]);
    }
    printf("\n");

    printf("Dark matter bin edges: ");
    for (int i = 0; i <= num_bins_dark; i++) {
        printf("%.6f ", dark_bin_edges[i]);
    }
    printf("\n");

    printf("Baryon bin centers: ");
    for (int i = 0; i < num_bins_baryon; i++) {
        printf("%.6f ", baryon_bin_centers[i]);
    }
    printf("\n");

    printf("Dark matter bin centers: ");
    for (int i = 0; i < num_bins_dark; i++) {
        printf("%.6f ", dark_bin_centers[i]);
    }
    printf("\n");
    fflush(stdout);
    
    // Calculate the theoretical density distribution for each component 
    baryon_theoretical_density = mwCallocA(num_bins_baryon, sizeof(real));
    dark_theoretical_density = mwCallocA(num_bins_dark, sizeof(real));
    
    if (baryon_theoretical_density == NULL || dark_theoretical_density == NULL) {
        fprintf(stderr, "Error: Failed to allocate memory for theoretical densities\n");
        if (baryon_theoretical_density) free(baryon_theoretical_density);
        if (dark_theoretical_density) free(dark_theoretical_density);
        failed = 1;
        goto cleanup;
    }

    // Calculate theoretical density for baryon component
    for (int i = 0; i < num_bins_baryon; i++) {
        baryon_theoretical_density[i] = counts_per_bin(comp1, baryon_bin_centers[i], 
                                         mass_per_particle_baryon, bin_width);
    }
    
    // Calculate theoretical density for dark matter component
    for (int i = 0; i < num_bins_dark; i++) {
        dark_theoretical_density[i] = counts_per_bin(comp2, dark_bin_centers[i], 
                                       mass_per_particle_dark, bin_width);
    }

    // Print the theoretical densities
    printf("Baryon theoretical density: ");
    for (int i = 0; i < num_bins_baryon; i++) {
        printf("%.6f ", baryon_theoretical_density[i]);
    }
    printf("\n");

    printf("Dark matter theoretical density: ");
    for (int i = 0; i < num_bins_dark; i++) {
        printf("%.6f ", dark_theoretical_density[i]);
    }
    printf("\n");
    fflush(stdout);
    
    // Normalize the theoretical densities and add epsilon to avoid division by zero and log(0) in KL divergence calculation
    baryon_theoretical_probability = smooth_and_normalize_distribution(baryon_theoretical_density, num_bins_baryon);
    dark_theoretical_probability = smooth_and_normalize_distribution(dark_theoretical_density, num_bins_dark);
    
    if (baryon_theoretical_probability == NULL || dark_theoretical_probability == NULL) {
        fprintf(stderr, "Error: Failed to normalize theoretical densities\n");
        if (baryon_theoretical_density) free(baryon_theoretical_density);
        if (dark_theoretical_density) free(dark_theoretical_density);
        if (baryon_theoretical_probability) free(baryon_theoretical_probability);
        if (dark_theoretical_probability) free(dark_theoretical_probability);
        failed = 1;
        goto cleanup;
    }

    // Print the theoretical probability densities
    printf("Baryon theoretical probability density: ");
    for (int i = 0; i < num_bins_baryon; i++) {
        printf("%.6f ", baryon_theoretical_probability[i]);
    }
    printf("\n");   

    printf("Dark matter theoretical probability density: ");
    for (int i = 0; i < num_bins_dark; i++) {
        printf("%.6f ", dark_theoretical_probability[i]);
    }
    printf("\n");
    fflush(stdout);

    // Run a simulation 
    printf("Running N-body simulation...\n");
    fflush(stdout);
    
    if (run_nbody(dwarf_params, input_lua_file) != 0) {
        fprintf(stderr, "Error: N-body simulation failed\n");
        fflush(stdout);
        failed = 1;
        goto cleanup;
    }
    
    printf("N-body simulation completed successfully\n");
    fflush(stdout);

    // Calculate the KL divergence at the initial timestep
    const char* initial_output_filename = "initial.out";
    printf("Checking for initial output file: %s\n", initial_output_filename);
    fflush(stdout);

    // Check if the initial output file exists
    if (access(initial_output_filename, F_OK) == -1) {
        fprintf(stderr, "Error: Initial output file '%s' does not exist\n", initial_output_filename);
        fflush(stdout);
        failed = 1;
        goto cleanup;
    }

    // Read the initial output file
    particle_data = read_particle_file(initial_output_filename);
    if (!particle_data) {
        fprintf(stderr, "Error: Failed to read initial output file '%s'\n", initial_output_filename);
        fflush(stdout);
        failed = 1;
        goto cleanup;
    }

    printf("Successfully read %zu particles from initial file\n", particle_data->count);
    fflush(stdout);
    
    // Validate particle count
    if (particle_data->count != (size_t)nbody) {
        fprintf(stderr, "Error: Expected %f particles but got %zu particles\n", 
               nbody, particle_data->count);
        free_particle_collection(particle_data);
        failed = 1;
        goto cleanup;
    }

    // Calculate the initial density distribution for each component
    baryon_simulation_density = mwCallocA(num_bins_baryon, sizeof(real));
    dark_simulation_density = mwCallocA(num_bins_dark, sizeof(real));
    
    if (baryon_simulation_density == NULL || dark_simulation_density == NULL) {
        fprintf(stderr, "Error: Failed to allocate memory for initial simulation densities\n");
        if (baryon_simulation_density) free(baryon_simulation_density);
        if (dark_simulation_density) free(dark_simulation_density);
        free_particle_collection(particle_data);
        failed = 1;
        goto cleanup;
    }

    // Initialize initial densities to zero
    for (int i = 0; i < num_bins_baryon; i++) {
        baryon_simulation_density[i] = 0.0;
    }
    for (int i = 0; i < num_bins_dark; i++) {
        dark_simulation_density[i] = 0.0;
    }

    // Calculate initial densities using histogram binning
    printf("Calculating initial densities for baryon particles...\n");
    fflush(stdout);
    
    for (int i = 0; i < (int)nbody_baryon && i < (int)particle_data->count; i++) {
        real radius = mw_sqrt(
            particle_data->particles[i].x * particle_data->particles[i].x + 
            particle_data->particles[i].y * particle_data->particles[i].y + 
            particle_data->particles[i].z * particle_data->particles[i].z
        );

        // Find the bin for this radius
        for (int bin = 0; bin < num_bins_baryon; bin++) {
            if (radius >= baryon_bin_edges[bin] && radius < baryon_bin_edges[bin + 1]) {
                baryon_simulation_density[bin] += 1.0;
                break;
            }
        }
    }

    printf("Calculating initial densities for dark matter particles...\n");
    fflush(stdout);
    
    for (int i = (int)nbody_baryon; i < (int)nbody && i < (int)particle_data->count; i++) {
        real radius = mw_sqrt(
            particle_data->particles[i].x * particle_data->particles[i].x + 
            particle_data->particles[i].y * particle_data->particles[i].y + 
            particle_data->particles[i].z * particle_data->particles[i].z
        );

        // Find the bin for this radius
        for (int bin = 0; bin < num_bins_dark; bin++) {
            if (radius >= dark_bin_edges[bin] && radius < dark_bin_edges[bin + 1]) {
                dark_simulation_density[bin] += 1.0;
                break;
            }
        }
    }

    // Print sample of initial densities
    printf("Initial baryon density distribution (first 5 values): ");
    for (int i = 0; i < num_bins_baryon && i < 5; i++) {
        printf("%.6f ", baryon_simulation_density[i]);
    }
    printf("...\n");
    
    printf("Initial dark matter density distribution (first 5 values): ");
    for (int i = 0; i < num_bins_dark && i < 5; i++) {
        printf("%.6f ", dark_simulation_density[i]);
    }
    printf("...\n");
    fflush(stdout);

    // Normalize the initial densities and add epsilon to avoid division by zero and log(0) in KL divergence calculation
    baryon_simulation_probability = smooth_and_normalize_distribution(baryon_simulation_density, num_bins_baryon);
    dark_simulation_probability = smooth_and_normalize_distribution(dark_simulation_density, num_bins_dark);
    
    if (baryon_simulation_probability == NULL || dark_simulation_probability == NULL) {
        fprintf(stderr, "Error: Failed to normalize initial simulation densities\n");
        if (baryon_simulation_density) free(baryon_simulation_density);
        if (dark_simulation_density) free(dark_simulation_density);
        if (baryon_simulation_probability) free(baryon_simulation_probability);
        if (dark_simulation_probability) free(dark_simulation_probability);
        free_particle_collection(particle_data);
        failed = 1;
        goto cleanup;
    }

    // Print sample of normalized initial densities
    printf("Initial simulation baryon probability density distribution (first 5 values): ");
    for (int i = 0; i < num_bins_baryon && i < 5; i++) {
        printf("%.6f ", baryon_simulation_probability[i]);
    }
    printf("...\n");
    
    printf("Initial simulation dark matter probability density distribution (first 5 values): ");
    for (int i = 0; i < num_bins_dark && i < 5; i++) {
        printf("%.6f ", dark_simulation_probability[i]);
    }
    printf("...\n");
    fflush(stdout);

    // Kullback-Leibler divergence for each component for the initial timestep
    initial_kl_divergence_baryon = kl_divergence(baryon_simulation_probability, baryon_theoretical_probability, num_bins_baryon);
    initial_kl_divergence_dark = kl_divergence(dark_simulation_probability, dark_theoretical_probability, num_bins_dark);

    printf("Initial KL divergence for baryon component: %f\n", initial_kl_divergence_baryon);
    printf("Initial KL divergence for dark matter component: %f\n", initial_kl_divergence_dark);
    fflush(stdout);

    if (initial_kl_divergence_baryon < 0 || initial_kl_divergence_dark < 0) {
        fprintf(stderr, "Error: Negative KL divergence indicates calculation error\n");
        free_particle_collection(particle_data);
        failed = 1;
        goto cleanup;
    }

    if (initial_kl_divergence_baryon > INITIAL_KL_THRESHOLD || initial_kl_divergence_dark > INITIAL_KL_THRESHOLD) {
        fprintf(stderr, "Error: Initial KL divergence is too high (> %f)\n", INITIAL_KL_THRESHOLD);
        fflush(stdout);
        free_particle_collection(particle_data);
        failed = 1;
        goto cleanup;
    }

    // Free the particle collection
    free_particle_collection(particle_data);
    printf("Particle collection freed successfully\n");
    fflush(stdout);

    // Calculate the total number of timesteps in the simulation (using dwarf_param[0] which is 2.0 Gyr)
    int total_timesteps = (int)(atof(dwarf_params[0]) / timestep);
    if (total_timesteps <= 0) {
        fprintf(stderr, "Error: Invalid total timesteps: %d\n", total_timesteps);
        failed = 1;
        goto cleanup;
    }
    printf("Total timesteps: %d\n", total_timesteps);
    fflush(stdout);

    // Calculate how many timesteps 0.1 Gyr is in the simulation
    int timesteps_0_1_Gyr = (int)(0.1 / timestep);
    if (timesteps_0_1_Gyr <= 0) {
        fprintf(stderr, "Error: Invalid timesteps per 0.1 Gyr: %d\n", timesteps_0_1_Gyr);
        failed = 1;
        goto cleanup;
    }
    printf("Timesteps per 0.1 Gyr: %d\n", timesteps_0_1_Gyr);
    fflush(stdout);

    // Calculating first timestep to start from
    int first_timestep = timesteps_0_1_Gyr - 1;
    if (first_timestep < 0) {
        first_timestep = 0;  // Ensure it's not negative
    }
    printf("First timestep to check: %d\n", first_timestep);
    fflush(stdout);
    
    // Calculate the KL divergence at multiple timesteps
    for (int i = first_timestep; i < total_timesteps; i += timesteps_0_1_Gyr) {
        printf("\n--- Processing timestep %d ---\n", i);
        fflush(stdout);
        
        char output_filename[MAX_PATH_LENGTH];
        snprintf(output_filename, sizeof(output_filename), "%d", i);
        printf("Checking for output file: %s\n", output_filename);
        fflush(stdout);
        
        // Check if the output file exists
        if (access(output_filename, F_OK) == -1) {
            fprintf(stderr, "Error: Output file '%s' does not exist\n", output_filename);
            fflush(stdout);
            failed = 1;
            goto cleanup;
        }
        
        printf("Output file exists, attempting to read...\n");
        fflush(stdout);
        
        particle_data = read_particle_file(output_filename);
        if (!particle_data) {
            fprintf(stderr, "Error: Failed to read particle file '%s'\n", output_filename);
            fflush(stdout);
            failed = 1;
            goto cleanup;
        }

        printf("Successfully read %zu particles\n", particle_data->count);
        fflush(stdout);

        // Calculate the simulation density distribution for each component
        real* simulation_density_baryon = mwCallocA(num_bins_baryon, sizeof(real));
        real* simulation_density_dark = mwCallocA(num_bins_dark, sizeof(real));
        
        if (simulation_density_baryon == NULL || simulation_density_dark == NULL) {
            fprintf(stderr, "Error: Failed to allocate memory for simulation densities\n");
            if (simulation_density_baryon) free(simulation_density_baryon);
            if (simulation_density_dark) free(simulation_density_dark);
            free_particle_collection(particle_data);
            failed = 1;
            goto cleanup;
        }

        // Initialize simulation densities to zero
        for (int j = 0; j < num_bins_baryon; j++) {
            simulation_density_baryon[j] = 0.0;
        }
        for (int j = 0; j < num_bins_dark; j++) {
            simulation_density_dark[j] = 0.0;
        }

        // Calculate simulation densities using histogram binning
        printf("Calculating simulation densities for baryon particles...\n");
        fflush(stdout);
        
        int baryon_particles_counted = 0;
        for (int j = 0; j < (int)nbody_baryon && j < (int)particle_data->count; j++) {
            real radius = mw_sqrt(
                particle_data->particles[j].x * particle_data->particles[j].x + 
                particle_data->particles[j].y * particle_data->particles[j].y + 
                particle_data->particles[j].z * particle_data->particles[j].z
            );

            // Find the bin for this radius
            for (int bin = 0; bin < num_bins_baryon; bin++) {
                if (radius >= baryon_bin_edges[bin] && radius < baryon_bin_edges[bin + 1]) {
                    simulation_density_baryon[bin] += 1.0;
                    baryon_particles_counted++;
                    break;
                }
            }
        }

        printf("Calculating simulation densities for dark matter particles...\n");
        fflush(stdout);
        
        int dark_particles_counted = 0;
        for (int j = (int)nbody_baryon; j < (int)nbody && j < (int)particle_data->count; j++) {
            real radius = mw_sqrt(
                particle_data->particles[j].x * particle_data->particles[j].x + 
                particle_data->particles[j].y * particle_data->particles[j].y + 
                particle_data->particles[j].z * particle_data->particles[j].z
            );

            // Find the bin for this radius
            for (int bin = 0; bin < num_bins_dark; bin++) {
                if (radius >= dark_bin_edges[bin] && radius < dark_bin_edges[bin + 1]) {
                    simulation_density_dark[bin] += 1.0;
                    dark_particles_counted++;
                    break;
                }
            }
        }
        
        printf("Particles counted: %d baryon, %d dark matter\n", 
               baryon_particles_counted, dark_particles_counted);
        fflush(stdout);

        // Print sample of simulation densities
        printf("Simulation baryon density distribution (first 5 values): ");
        for (int j = 0; j < num_bins_baryon && j < 5; j++) {
            printf("%.6f ", simulation_density_baryon[j]);
        }
        printf("...\n");
        
        printf("Simulation dark matter density distribution (first 5 values): ");
        for (int j = 0; j < num_bins_dark && j < 5; j++) {
            printf("%.6f ", simulation_density_dark[j]);
        }
        printf("...\n");
        fflush(stdout);

        // Normalize the simulation densities and add epsilon to avoid division by zero and log(0) in KL divergence calculation 
        real* simulation_probability_density_baryon = smooth_and_normalize_distribution(simulation_density_baryon, num_bins_baryon);
        real* simulation_probability_density_dark = smooth_and_normalize_distribution(simulation_density_dark, num_bins_dark);
        
        if (simulation_probability_density_baryon == NULL || simulation_probability_density_dark == NULL) {
            fprintf(stderr, "Error: Failed to normalize simulation densities\n");
            if (simulation_density_baryon) free(simulation_density_baryon);
            if (simulation_density_dark) free(simulation_density_dark);
            if (simulation_probability_density_baryon) free(simulation_probability_density_baryon);
            if (simulation_probability_density_dark) free(simulation_probability_density_dark);
            free_particle_collection(particle_data);
            failed = 1;
            goto cleanup;
        }

        // Print sample of normalized simulation densities
        printf("Simulation baryon probability density distribution (first 5 values): ");
        for (int j = 0; j < num_bins_baryon && j < 5; j++) {
            printf("%.6f ", simulation_probability_density_baryon[j]);
        }
        printf("...\n");
        
        printf("Simulation dark matter probability density distribution (first 5 values): ");
        for (int j = 0; j < num_bins_dark && j < 5; j++) {
            printf("%.6f ", simulation_probability_density_dark[j]);
        }
        printf("...\n");
        fflush(stdout);

        // Kullback-Leibler divergence for each component
        real kl_divergence_baryon = kl_divergence(simulation_probability_density_baryon, baryon_theoretical_probability, num_bins_baryon);
        real kl_divergence_dark = kl_divergence(simulation_probability_density_dark, dark_theoretical_probability, num_bins_dark);

        printf("KL divergence for baryon component: %f\n", kl_divergence_baryon);
        printf("KL divergence for dark matter component: %f\n", kl_divergence_dark);
        printf("Difference from initial KL divergence (baryon): %f\n", mw_fabs(kl_divergence_baryon - initial_kl_divergence_baryon));
        printf("Difference from initial KL divergence (dark): %f\n", mw_fabs(kl_divergence_dark - initial_kl_divergence_dark));
        fflush(stdout);

        if (kl_divergence_baryon < 0 || kl_divergence_dark < 0) {
            fprintf(stderr, "Error: Negative KL divergence indicates calculation error\n");
            free(simulation_probability_density_baryon);
            free(simulation_probability_density_dark);
            free(simulation_density_baryon);
            free(simulation_density_dark);
            free_particle_collection(particle_data);
            failed = 1;
            goto cleanup;
        }

        if (mw_fabs(kl_divergence_baryon - initial_kl_divergence_baryon) > KL_FLUCTUATION_THRESHOLD || 
            mw_fabs(kl_divergence_dark - initial_kl_divergence_dark) > KL_FLUCTUATION_THRESHOLD) {
            fprintf(stderr, "Error: KL divergence fluctuation is too high (> %f) showing instability\n", 
                   KL_FLUCTUATION_THRESHOLD);
            fflush(stdout);
            
            // Free allocated memory for this simulation iteration
            free(simulation_probability_density_baryon);
            free(simulation_probability_density_dark);
            free(simulation_density_baryon);
            free(simulation_density_dark);
            free_particle_collection(particle_data);
            failed = 1;
            goto cleanup;
        }

        // Free allocated memory for this simulation iteration
        free(simulation_probability_density_baryon);
        free(simulation_probability_density_dark);
        free(simulation_density_baryon);
        free(simulation_density_dark);
        
        // Free data at the end of each iteration
        free_particle_collection(particle_data);
        printf("Particle collection freed successfully\n");
        fflush(stdout);
    }
    
    // Free memory for probability densities
    free(baryon_simulation_probability);
    baryon_simulation_probability = NULL;
    free(dark_simulation_probability);
    dark_simulation_probability = NULL;
    
    // Free memory at the end of function
    free(input_lua_file);
    input_lua_file = NULL;
    
    // Free additional memory that wasn't being freed before
    free(baryon_bin_centers);
    baryon_bin_centers = NULL;
    free(dark_bin_centers);
    dark_bin_centers = NULL;
    free(baryon_bin_edges);
    baryon_bin_edges = NULL;
    free(dark_bin_edges);
    dark_bin_edges = NULL;
    free(baryon_theoretical_density);
    baryon_theoretical_density = NULL;
    free(dark_theoretical_density);
    dark_theoretical_density = NULL;
    free(baryon_simulation_density);
    baryon_simulation_density = NULL;
    free(dark_simulation_density);
    dark_simulation_density = NULL;
    
    // If we get here, all KL divergence tests passed
    printf("All stability tests passed successfully!\n");
    fflush(stdout);
    
    // Success - return directly instead of falling through to cleanup
    failed = 0;
    return failed;
    
cleanup:
    // Centralized cleanup for all allocated memory
    cleanup_all_memory(
        input_lua_file, 
        baryon_bin_centers, dark_bin_centers,
        baryon_bin_edges, dark_bin_edges,
        baryon_theoretical_density, dark_theoretical_density,
        baryon_theoretical_probability, dark_theoretical_probability,
        baryon_simulation_density, dark_simulation_density,
        baryon_simulation_probability, dark_simulation_probability,
        particle_data
    );
    
    if (failed == 0) {
        printf("Test completed successfully\n");
    } else {
        printf("Test failed\n");
    }
    fflush(stdout);
    
    return failed;
}

/**
 * @brief Main function for the stability test
 * 
 * @return 0 if all tests passed, 1 if any test failed
 */
int main() {

    int failed = 0;
    int total_failed = 0;

    // List of dwarf models to test
    const char* dwarf_models[] = {
        "plummer_plummer.lua",
        "plummer_nfw.lua",
        "cored_cored.lua" 
    };

    // Number of models to test
    int num_models = sizeof(dwarf_models) / sizeof(dwarf_models[0]);

    // Test each model
    for (int i = 0; i < num_models; i++) {
        printf("\n=== Testing %s ===\n", dwarf_models[i]);
        failed = testStability(dwarf_models[i]);
        if (failed == 0) {
            printf("✓ %s passed all tests!\n", dwarf_models[i]);
        } else {
            printf("✗ %s failed %d tests!\n", dwarf_models[i], failed);
            total_failed += failed;
        }
    }

	if(total_failed == 0)
	{
		printf("\n=== SUMMARY ===\n");
		printf("All Kullback-Leibler divergence stability tests successful!\n");
	}
	else
	{
		printf("\n=== SUMMARY ===\n");
		printf("Failed %d tests across all models\n", total_failed);
	}

    return total_failed > 0 ? 1 : 0;
}
