/* This program tests the stability of a 2-component dwarf galaxy.
* Dwarf galaxy types tested in this program:
* 1. Plummer-Plummer
* Stability is determined by Kullback-Leibler divergence calculation of the theoretical probability density distribution
* and the normalized density distribution generated by MilkyWay@home.  
* Since the distribution of baryons and dark matter are determined separately, the program calculates the KL divergence for each component.
* If unstable, the generated density distribution tends to oscillate from looking stable to unstable.
* Because of this, the program calculates the KL divergence for each component at multiple time steps as to not accidentally conclude that an unstable system is stable.
*/

/* TODO:
* Change the lua file to use the get_soft_par() function to get the softening parameter instead of a hard coded value.
* Add NFW profile test.
* Add cored profile test.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <errno.h>
#include "nbody.h"
#include "nbody_particle_data.h"
#include "nbody_dwarf_potential.h"
#include "nbody_types.h"
#include "nbody_lua.h"
#include "nbody_lua_types.h"
#include "nbody_lua_models.h"
#include "milkyway_alloc.h"
#include "milkyway_math.h"

/* Dwarf galaxy parameters */
#define EVOLUTION_TIME "2.0"                  /* Evolution time in Gyr */
#define EVOLUTION_RATIO "0.0"                 /* Evolution time ratio */
#define BARYON_SCALE_RADIUS "0.181216"        /* Baryon Scale radius in kpc */
#define SCALE_RADIUS_RATIO "0.182799"         /* Scale radius ratio */
#define BARYON_MASS "1.22251"                 /* Baryon Mass in SMU */
#define MASS_RATIO "0.0126171"                /* Mass ratio */

/* KL divergence thresholds */
#define INITIAL_KL_THRESHOLD 0.01   /* Maximum acceptable initial KL divergence */
#define KL_FLUCTUATION_THRESHOLD 0.005 /* Maximum acceptable KL divergence fluctuation */

/* Search paths configuration */
#define MAX_SEARCH_PATHS 10        /* Maximum number of paths to search */
#define MAX_PATH_LENGTH 1024       /* Maximum length of a path */

/* Function prototypes for memory management */
static void cleanup_all_memory(
    char* input_lua_file,
    real* baryon_radius_array, real* dark_radius_array,
    real* baryon_bin_edges, real* dark_bin_edges,
    real* baryon_theoretical_density, real* dark_theoretical_density,
    real* baryon_theoretical_probability, real* dark_theoretical_probability,
    real* baryon_simulation_density, real* dark_simulation_density,
    real* baryon_simulation_probability, real* dark_simulation_probability,
    ParticleCollection* particle_data
);

/**
 * @brief Calculate the mass enclosed within a given radius for a dwarf component
 * 
 * @param comp The dwarf component
 * @param radius The radius to calculate mass within
 * @return real The enclosed mass
 */
static real mass_enclosed_function(const Dwarf *comp, real radius) {
    if (comp == NULL) {
        fprintf(stderr, "Error: Null dwarf component in mass_enclosed_function\n");
        return 0.0;
    }
    return 4.0 * M_PI * sqr(radius) * get_density(comp, radius);
}

/**
 * @brief Calculate the expected counts per bin for a given radius
 * 
 * @param comp The dwarf component
 * @param radius The radius to calculate at
 * @param mass_per_particle Mass per particle
 * @param bin_width Width of histogram bin
 * @return real The expected counts
 */
static real counts_per_bin(const Dwarf *comp, real radius, real mass_per_particle, real bin_width) {
    if (comp == NULL || mass_per_particle <= 0.0 || bin_width <= 0.0) {
        fprintf(stderr, "Error: Invalid parameters in counts_per_bin\n");
        return 0.0;
    }
    return mass_enclosed_function(comp, radius) * (1.0 / mass_per_particle) * bin_width;
}

/**
 * @brief Smooth and normalize a density distribution into a probability distribution
 * 
 * Adds a small epsilon to avoid zeros and normalize the distribution to sum to 1.0
 * 
 * @param counts Array of counts
 * @param size Size of the array
 * @return real* Newly allocated array with normalized counts
 */
static real* smooth_and_normalize_distribution(real* counts, size_t size) {   
    if (counts == NULL || size == 0) {
        fprintf(stderr, "Error: Invalid parameters in smooth_and_normalize_distribution\n");
        return NULL;
    }
    
    real epsilon = 1e-10;
    real sum = 0.0;
    real* normalized_counts = mwCallocA(size, sizeof(real));  
    if (normalized_counts == NULL) {
        fprintf(stderr, "Error: Memory allocation failed in smooth_and_normalize_distribution\n");
        return NULL;
    }

    // Add epsilon and calculate sum
    for (size_t i = 0; i < size; i++) {
        counts[i] += epsilon;
        sum += counts[i];
    }
        
    // Normalize the counts
    for (size_t i = 0; i < size; i++) {
        normalized_counts[i] = counts[i] / sum;
    }
    return normalized_counts;
}

/**
 * @brief Calculate the Kullback-Leibler divergence between two probability distributions
 * 
 * @param p Simulation probability distribution
 * @param q Theoretical probability distribution
 * @param size Size of the distributions
 * @return real The KL divergence
 */
static real kl_divergence(const real *p, const real *q, size_t size) {
    if (p == NULL || q == NULL || size == 0) {
        fprintf(stderr, "Error: Invalid parameters in kl_divergence\n");
        return -1.0;
    }
    
    real kl_div = 0.0;
    
    for (size_t i = 0; i < size; i++) {
        if (p[i] <= 0.0 || q[i] <= 0.0) {
            fprintf(stderr, "Warning: Non-positive value in KL divergence at index %zu: p=%f, q=%f\n", 
                   i, p[i], q[i]);
            continue;
        }
        kl_div += p[i] * mw_log(p[i] / q[i]);
    }
    
    return kl_div;
}

/**
 * @brief Find the test lua file using multiple search paths
 * 
 * @param filename The filename to search for
 * @return char* Path to the file if found, NULL otherwise (caller must free)
 */
static char* find_lua_file(const char* filename) {
    if (filename == NULL || strlen(filename) == 0) {
        fprintf(stderr, "Error: Invalid filename provided to find_lua_file\n");
        return NULL;
    }
    
    char* result = mwCallocA(MAX_PATH_LENGTH, sizeof(char));
    if (result == NULL) {
        fprintf(stderr, "Error: Memory allocation failed in find_lua_file\n");
        return NULL;
    }
    
    char cwd[MAX_PATH_LENGTH];
    if (getcwd(cwd, sizeof(cwd)) == NULL) {
        fprintf(stderr, "Error: Failed to get current working directory: %s\n", strerror(errno));
        free(result);
        return NULL;
    }
    
    // Try common relative paths for different possible execution locations
    const char* relative_paths[] = {
        "../../../nbody/sample_workunits/test_env_lua",
        "/../nbody/sample_workunits/test_env_lua",
        "../nbody/sample_workunits/test_env_lua",
        "../sample_workunits/test_env_lua",
        "../test_env_lua"
    };
    
    size_t num_paths = sizeof(relative_paths) / sizeof(relative_paths[0]);
        
    // Try each relative path
    for (size_t i = 0; i < num_paths && i < MAX_SEARCH_PATHS; i++) {
        if (strlen(relative_paths[i]) == 0) {
            // Current directory
            snprintf(result, MAX_PATH_LENGTH, "%s/%s", cwd, filename);
        } else {
            snprintf(result, MAX_PATH_LENGTH, "%s%s/%s", 
                    (relative_paths[i][0] == '/') ? cwd : "", 
                    relative_paths[i], filename);
        }
        
        printf("Trying path: %s\n", result);
        fflush(stdout);
        
        if (access(result, F_OK) != -1) {
            printf("Found file at: %s\n", result);
            fflush(stdout);
            return result;
        }
    }
    
    // File not found
    fprintf(stderr, "Error: Could not find file '%s' in any search path\n", filename);
    free(result);
    return NULL;
}

/**
 * @brief Find the milkyway_nbody executable
 * 
 * @return char* Path to the executable if found, NULL otherwise (caller must free)
 */
static char* find_milkyway_nbody() {
    char* result = mwCallocA(MAX_PATH_LENGTH, sizeof(char));
    if (result == NULL) {
        fprintf(stderr, "Error: Memory allocation failed in find_milkyway_nbody\n");
        return NULL;
    }
    
    char cwd[MAX_PATH_LENGTH];
    if (getcwd(cwd, sizeof(cwd)) == NULL) {
        fprintf(stderr, "Error: Failed to get current working directory: %s\n", strerror(errno));
        free(result);
        return NULL;
    }
    
    // Try common relative paths for the executable
    const char* relative_paths[] = {
        "../../bin",
        "../bin",
        "bin",
        "..",
        "../.."
    };
    
    size_t num_paths = sizeof(relative_paths) / sizeof(relative_paths[0]);
    
    // Try each relative path
    for (size_t i = 0; i < num_paths && i < MAX_SEARCH_PATHS; i++) {
        snprintf(result, MAX_PATH_LENGTH, "%s/%s/milkyway_nbody", cwd, relative_paths[i]);
        
        // For the current directory option, don't add an extra slash
        if (strcmp(relative_paths[i], ".") == 0) {
            snprintf(result, MAX_PATH_LENGTH, "%s/milkyway_nbody", cwd);
        }
        
        printf("Trying executable path: %s\n", result);
        fflush(stdout);
        
        if (access(result, X_OK) != -1) {
            printf("Found executable at: %s\n", result);
            fflush(stdout);
            return result;
        }
    }
    
    // If not found with relative paths, try to find it in PATH
    snprintf(result, MAX_PATH_LENGTH, "milkyway_nbody");
    if (system("which milkyway_nbody > /dev/null 2>&1") == 0) {
        printf("Found executable in PATH: milkyway_nbody\n");
        fflush(stdout);
        return result;
    }
    
    // Executable not found
    fprintf(stderr, "Error: Could not find milkyway_nbody executable\n");
    free(result);
    return NULL;
}

/**
 * @brief Run the nbody simulation with the given parameters
 * 
 * @param dwarf_params Array of parameters for the dwarf galaxy
 * @param lua_file Path to the Lua file
 * @return int 0 on success, non-zero on failure
 */
int run_nbody(const char** dwarf_params, const char* lua_file) {
    if (!dwarf_params) {
        fprintf(stderr, "Error: Null dwarf parameters array in run_nbody\n");
        return 1;
    }
    
    if (!lua_file) {
        fprintf(stderr, "Error: Null Lua file path in run_nbody\n");
        return 1;
    }
    
    // Validate the lua file exists
    if (access(lua_file, F_OK) == -1) {
        fprintf(stderr, "Error: Lua file '%s' does not exist\n", lua_file);
        return 1;
    }

    char command[MAX_PATH_LENGTH * 2];  // Larger buffer for the command
    char cwd[MAX_PATH_LENGTH];
    
    if (getcwd(cwd, sizeof(cwd)) == NULL) {
        fprintf(stderr, "Error: Failed to get current working directory: %s\n", strerror(errno));
        return 1;
    }
    
    // Find the milkyway_nbody executable
    char* bin_path = find_milkyway_nbody();
    if (!bin_path) {
        fprintf(stderr, "Error: Could not find milkyway_nbody executable\n");
        return 1;
    }
    
    // Validate all parameters before building command
    for (int i = 0; i < 6; i++) {
        if (!dwarf_params[i] || strlen(dwarf_params[i]) == 0) {
            fprintf(stderr, "Error: Invalid dwarf parameter at index %d\n", i);
            free(bin_path);
            return 1;
        }
    }
    
    // Build the command with proper escaping
    snprintf(command, sizeof(command), 
             "%s "
             "-f \"%s\" "
             "-o \"%s/output.out\" "
             "-z \"%s/output.hist\" "
             "-n 8 -b -w 1 -P -e 54231651 "
             "-i %s %s %s %s %s %s",
             bin_path, lua_file, cwd, cwd,
             dwarf_params[0], dwarf_params[1], dwarf_params[2], 
             dwarf_params[3], dwarf_params[4], dwarf_params[5]);
    
    printf("Running command: %s\n", command);
    fflush(stdout);
    
    int result = system(command);
    if (result != 0) {
        fprintf(stderr, "Error: Command execution failed with code %d\n", result);
    }
    
    // Free memory
    free(bin_path);
    
    return result;
}

/**
 * @brief Read parameters from a Lua file
 * 
 * @param input_lua_file Path to the Lua file
 * @param dwarf_params Array of parameters for the dwarf galaxy
 * @param nbody Output: total number of bodies
 * @param nbody_baryon Output: number of baryon bodies
 * @param comp1 Output: first dwarf component
 * @param comp2 Output: second dwarf component
 * @param timestep Output: simulation timestep
 * @return int 0 on success, non-zero on failure
 */
int read_lua_parameters(const char* input_lua_file, const char** dwarf_params, real* nbody, real* nbody_baryon, Dwarf** comp1, Dwarf** comp2, real* timestep) {
    if (!input_lua_file || !dwarf_params || !nbody || !nbody_baryon || !comp1 || !comp2 || !timestep) {
        fprintf(stderr, "Error: Null parameter provided to read_lua_parameters\n");
        return 1;
    }
    
    printf("Opening Lua state with file: %s\n", input_lua_file);
    fflush(stdout);
    
    // Validate the lua file exists
    if (access(input_lua_file, F_OK) == -1) {
        fprintf(stderr, "Error: Lua file '%s' does not exist\n", input_lua_file);
        return 1;
    }
    
    NBodyFlags nbf = {
        .inputFile = input_lua_file,
        .debugLuaLibs = TRUE,  // Enable debug output
        .forwardedArgs = dwarf_params,
        .numForwardedArgs = 6
    };

    lua_State* L = nbOpenLuaStateWithScript(&nbf, NULL);
    if (!L) {
        fprintf(stderr, "Failed to open Lua state with script %s\n", input_lua_file);
        fflush(stdout);
        return 1;
    }

    // Register all necessary types and models
    registerNBodyTypes(L);
    registerPredefinedModelGenerators(L);

    // Get nbody values from global variables 
    lua_getglobal(L, "totalBodies");
    if (!lua_isnumber(L, -1)) {
        fprintf(stderr, "Error: totalBodies is not a number in Lua file\n");
        fflush(stdout);
        lua_close(L);
        return 1;
    }
    *nbody = lua_tonumber(L, -1);
    printf("totalBodies from Lua: %f\n", *nbody);
    fflush(stdout);
    lua_pop(L, 1);

    lua_getglobal(L, "totalLightBodies");
    if (!lua_isnumber(L, -1)) {
        fprintf(stderr, "Error: totalLightBodies is not a number in Lua file\n");
        fflush(stdout);
        lua_close(L);
        return 1;
    }
    *nbody_baryon = lua_tonumber(L, -1);
    printf("totalLightBodies from Lua: %f\n", *nbody_baryon);
    fflush(stdout);
    lua_pop(L, 1);

    // Validate nbody values before proceeding
    if (*nbody <= 0 || *nbody_baryon <= 0 || *nbody_baryon > *nbody) {
        fprintf(stderr, "Error: Invalid nbody values - nbody: %f, nbody_baryon: %f\n", *nbody, *nbody_baryon);
        fflush(stdout);
        lua_close(L);
        return 1;
    }

    // Get the makeBodies function
    lua_getglobal(L, "makeBodies");
    if (!lua_isfunction(L, -1)) {
        fprintf(stderr, "Error: makeBodies function not found in Lua script\n");
        fflush(stdout);
        lua_close(L);
        return 1;
    }

    // Get the makeContext function
    lua_getglobal(L, "makeContext");
    if (!lua_isfunction(L, -1)) {
        fprintf(stderr, "Error: makeContext function not found in Lua script\n");
        fflush(stdout);
        lua_close(L);
        return 1;
    }

    // Call makeContext
    printf("Calling makeContext...\n");
    fflush(stdout);
    if (lua_pcall(L, 0, 1, 0) != 0) {
        fprintf(stderr, "Error calling makeContext: %s\n", lua_tostring(L, -1));
        fflush(stdout);
        lua_close(L);
        return 1;
    }

    // Get the timestep from the context
    lua_getfield(L, -1, "timestep");
    if (!lua_isnumber(L, -1)) {
        fprintf(stderr, "Error: timestep is not a number in Lua context\n");
        fflush(stdout);
        lua_close(L);
        return 1;
    }
    *timestep = lua_tonumber(L, -1);
    lua_pop(L, 1);

    // Validate timestep
    if (*timestep <= 0.0 || !isfinite(*timestep)) {
        fprintf(stderr, "Error: Invalid timestep value: %f\n", *timestep);
        fflush(stdout);
        lua_close(L);
        return 1;
    }
    printf("Valid timestep value: %f\n", *timestep);
    fflush(stdout);

    // Push nil for potential
    lua_pushnil(L);

    // Call makeBodies
    printf("Calling makeBodies...\n");
    fflush(stdout);
    if (lua_pcall(L, 2, 1, 0) != 0) {
        fprintf(stderr, "Error calling makeBodies: %s\n", lua_tostring(L, -1));
        fflush(stdout);
        lua_close(L);
        return 1;
    }

    // Get the components from the model's table
    lua_getfield(L, -1, "components");
    if (!lua_istable(L, -1)) {
        fprintf(stderr, "Error: components table not found in model\n");
        fflush(stdout);
        lua_close(L);
        return 1;
    }

    // Get comp1
    lua_getfield(L, -1, "comp1");
    if (!lua_isuserdata(L, -1)) {
        fprintf(stderr, "Error: comp1 is not a userdata in Lua model\n");
        fflush(stdout);
        lua_close(L);
        return 1;
    }
    *comp1 = (Dwarf*)lua_touserdata(L, -1);
    lua_pop(L, 1);

    // Get comp2
    lua_getfield(L, -1, "comp2");
    if (!lua_isuserdata(L, -1)) {
        fprintf(stderr, "Error: comp2 is not a userdata in Lua model\n");
        fflush(stdout);
        lua_close(L);
        return 1;
    }
    *comp2 = (Dwarf*)lua_touserdata(L, -1);
    lua_pop(L, 1);

    // Validate the components
    if (!*comp1 || !*comp2) {
        fprintf(stderr, "Error: Invalid dwarf components\n");
        fflush(stdout);
        lua_close(L);
        return 1;
    }

    printf("Read parameters from Lua file:\n");
    printf("nbody: %f\n", *nbody);
    printf("nbody_baryon: %f\n", *nbody_baryon);
    printf("comp1 mass: %f\n", (*comp1)->mass);
    printf("comp1 scale length: %f\n", (*comp1)->scaleLength);
    printf("comp2 mass: %f\n", (*comp2)->mass);
    printf("comp2 scale length: %f\n", (*comp2)->scaleLength);
    printf("timestep: %f\n", *timestep);
    fflush(stdout);

    // Validate component parameters
    if ((*comp1)->mass <= 0 || (*comp1)->scaleLength <= 0 || 
        (*comp2)->mass <= 0 || (*comp2)->scaleLength <= 0) {
        fprintf(stderr, "Error: Invalid component parameters\n");
        fflush(stdout);
        lua_close(L);
        return 1;
    }

    lua_close(L);
    return 0;
}

/**
 * @brief Clean up all allocated memory
 */
static void cleanup_all_memory(
    char* input_lua_file,
    real* baryon_radius_array, real* dark_radius_array,
    real* baryon_bin_edges, real* dark_bin_edges,
    real* baryon_theoretical_density, real* dark_theoretical_density,
    real* baryon_theoretical_probability, real* dark_theoretical_probability,
    real* baryon_simulation_density, real* dark_simulation_density,
    real* baryon_simulation_probability, real* dark_simulation_probability,
    ParticleCollection* particle_data
) {
    // Free all memory - safe to call with NULL pointers
    free(input_lua_file);
    free(baryon_radius_array);
    free(dark_radius_array);
    free(baryon_bin_edges);
    free(dark_bin_edges);
    free(baryon_theoretical_density);
    free(dark_theoretical_density);
    free(baryon_theoretical_probability);
    free(dark_theoretical_probability);
    free(baryon_simulation_density);
    free(dark_simulation_density);
    free(baryon_simulation_probability);
    free(dark_simulation_probability);
    
    if (particle_data) {
        free_particle_collection(particle_data);
    }
}

/**
 * @brief Main function for the stability test
 * 
 * @return int 0 on success, non-zero on failure
 */
int main() {
    printf("Starting stability test...\n");
    fflush(stdout);
    
    // Initialize all pointers to NULL
    char* input_lua_file = NULL;
    real* baryon_radius_array = NULL;
    real* dark_radius_array = NULL;
    real* baryon_bin_edges = NULL;
    real* dark_bin_edges = NULL;
    real* baryon_theoretical_density = NULL;
    real* dark_theoretical_density = NULL;
    real* baryon_theoretical_probability = NULL;
    real* dark_theoretical_probability = NULL;
    real* baryon_simulation_density = NULL;
    real* dark_simulation_density = NULL;
    real* baryon_simulation_probability = NULL;
    real* dark_simulation_probability = NULL;
    ParticleCollection* particle_data = NULL;
    
    // Initialize other variables
    real nbody = 0.0;
    real nbody_baryon = 0.0;
    real nbody_dark = 0.0;
    Dwarf *comp1 = NULL;
    Dwarf *comp2 = NULL;
    real timestep = 0.0;
    real mass_per_particle_baryon = 0.0;
    real mass_per_particle_dark = 0.0;
    real bin_width = 0.0;
    int num_bins_baryon = 0;
    int num_bins_dark = 0;
    real initial_kl_divergence_baryon = 0.0;
    real initial_kl_divergence_dark = 0.0;
    int result = 0;
    
    // Clean up any output files from previous runs
    printf("Cleaning up any output files from previous runs...\n");
    fflush(stdout);
    
    char output_filename[MAX_PATH_LENGTH];
    // Remove output files with numeric names (0, 1, 2, etc.)
    for (int i = 0; i < 10000; i++) {
        snprintf(output_filename, sizeof(output_filename), "%d", i);
        if (access(output_filename, F_OK) != -1) {
            if (remove(output_filename) == 0) {
                printf("Removed old output file: %s\n", output_filename);
            } else {
                fprintf(stderr, "Failed to remove old output file: %s - %s\n", 
                      output_filename, strerror(errno));
            }
        }
    }
    
    // Remove other output files
    const char* other_output_files[] = {"output.out", "output.hist"};
    for (int i = 0; i < sizeof(other_output_files) / sizeof(other_output_files[0]); i++) {
        if (access(other_output_files[i], F_OK) != -1) {
            if (remove(other_output_files[i]) == 0) {
                printf("Removed old output file: %s\n", other_output_files[i]);
            } else {
                fprintf(stderr, "Failed to remove old output file: %s - %s\n", 
                      other_output_files[i], strerror(errno));
            }
        }
    }
    printf("Cleanup complete.\n");
    fflush(stdout);

    const char* dwarf_params[] = {
        EVOLUTION_TIME,
        EVOLUTION_RATIO,
        BARYON_SCALE_RADIUS,
        SCALE_RADIUS_RATIO,
        BARYON_MASS,
        MASS_RATIO
    };
    
    // Find the plummer_plummer.lua file
    input_lua_file = find_lua_file("plummer_plummer.lua");
    if (!input_lua_file) {
        fprintf(stderr, "Error: Could not find plummer_plummer.lua in any expected location\n");
        result = 1;
        goto cleanup;
    }
    
    printf("Input file path: %s\n", input_lua_file);
    fflush(stdout);

    // First, read the parameters from the Lua file
    printf("Reading Lua parameters...\n");
    fflush(stdout);
    if (read_lua_parameters(input_lua_file, dwarf_params, &nbody, &nbody_baryon, &comp1, &comp2, &timestep) != 0) {
        fprintf(stderr, "Error: Failed to read Lua parameters\n");
        fflush(stdout);
        result = 1;
        goto cleanup;
    }

    // Calculate the mass per particle for each component
    nbody_dark = nbody - nbody_baryon;
    if (nbody_dark <= 0) {
        fprintf(stderr, "Error: Invalid number of dark matter particles: %f\n", nbody_dark);
        result = 1;
        goto cleanup;
    }
    
    // Validate component parameters
    if (comp1 == NULL || comp2 == NULL) {
        fprintf(stderr, "Error: Invalid dwarf components (NULL)\n");
        result = 1;
        goto cleanup;
    }
    
    if (comp1->mass <= 0 || comp2->mass <= 0) {
        fprintf(stderr, "Error: Invalid component masses: comp1=%f, comp2=%f\n", 
               comp1->mass, comp2->mass);
        result = 1;
        goto cleanup;
    }
    
    mass_per_particle_baryon = comp1->mass / nbody_baryon;
    mass_per_particle_dark = comp2->mass / nbody_dark;
    
    if (mass_per_particle_baryon <= 0 || mass_per_particle_dark <= 0) {
        fprintf(stderr, "Error: Invalid mass per particle: baryon=%f, dark=%f\n", 
               mass_per_particle_baryon, mass_per_particle_dark);
        result = 1;
        goto cleanup;
    }
    
    printf("mass_per_particle_baryon: %f\n", mass_per_particle_baryon);
    printf("mass_per_particle_dark: %f\n", mass_per_particle_dark);
    fflush(stdout);

    // Calculating bin width
    if (comp1->scaleLength <= 0 || comp2->scaleLength <= 0) {
        fprintf(stderr, "Error: Invalid scale lengths: comp1=%f, comp2=%f\n", 
               comp1->scaleLength, comp2->scaleLength);
        result = 1;
        goto cleanup;
    }
    
    bin_width = mw_fmin(comp1->scaleLength, comp2->scaleLength) / 5.0;
    if (bin_width <= 0) {
        fprintf(stderr, "Error: Invalid bin width: %f\n", bin_width);
        result = 1;
        goto cleanup;
    }
    
    printf("Bin width: %f\n", bin_width);
    fflush(stdout);

    // Calculate number of bins needed for each component (matching np.arange)
    num_bins_baryon = (int)((4.0 * comp1->scaleLength - 0.2 * comp1->scaleLength) / bin_width) + 1;
    num_bins_dark = (int)((4.0 * comp2->scaleLength - 0.2 * comp2->scaleLength) / bin_width) + 1;
    
    if (num_bins_baryon <= 0 || num_bins_dark <= 0) {
        fprintf(stderr, "Error: Invalid number of bins: baryon=%d, dark=%d\n", 
               num_bins_baryon, num_bins_dark);
        result = 1;
        goto cleanup;
    }

    printf("Using %d bins for baryon component and %d bins for dark matter component\n", 
           num_bins_baryon, num_bins_dark);
    fflush(stdout);

    // Creating radius arrays for KL divergence calculation for each component (bin centers)
    baryon_radius_array = mwCallocA(num_bins_baryon, sizeof(real));
    dark_radius_array = mwCallocA(num_bins_dark, sizeof(real));
    
    if (baryon_radius_array == NULL || dark_radius_array == NULL) {
        fprintf(stderr, "Error: Failed to allocate memory for radius arrays\n");
        result = 1;
        goto cleanup;
    }

    // Create bin edges 
    baryon_bin_edges = mwCallocA(num_bins_baryon + 1, sizeof(real));
    dark_bin_edges = mwCallocA(num_bins_dark + 1, sizeof(real));
    
    if (baryon_bin_edges == NULL || dark_bin_edges == NULL) {
        fprintf(stderr, "Error: Failed to allocate memory for bin edges\n");
        result = 1;
        goto cleanup;
    }

    // Initialize baryon bin edges
    for (int i = 0; i <= num_bins_baryon; i++) {
        baryon_bin_edges[i] = 0.2 * comp1->scaleLength + i * bin_width;
    }

    // Initialize baryon bin centers
    for (int i = 0; i < num_bins_baryon; i++) {
        baryon_radius_array[i] = baryon_bin_edges[i] + bin_width / 2.0;
    }
    
    // Initialize dark matter bin edges
    for (int i = 0; i <= num_bins_dark; i++) {
        dark_bin_edges[i] = 0.2 * comp2->scaleLength + i * bin_width;
    }

    // Initialize dark matter bin centers
    for (int i = 0; i < num_bins_dark; i++) {
        dark_radius_array[i] = dark_bin_edges[i] + bin_width / 2.0;
    }

    // Print the bin edges and centers
    printf("Baryon bin edges: ");
    for (int i = 0; i <= num_bins_baryon; i++) {
        printf("%.6f ", baryon_bin_edges[i]);
    }
    printf("\n");

    printf("Dark matter bin edges: ");
    for (int i = 0; i <= num_bins_dark; i++) {
        printf("%.6f ", dark_bin_edges[i]);
    }
    printf("\n");

    printf("Baryon bin centers: ");
    for (int i = 0; i < num_bins_baryon; i++) {
        printf("%.6f ", baryon_radius_array[i]);
    }
    printf("\n");

    printf("Dark matter bin centers: ");
    for (int i = 0; i < num_bins_dark; i++) {
        printf("%.6f ", dark_radius_array[i]);
    }
    printf("\n");
    fflush(stdout);
    
    // Calculate the theoretical density distribution for each component 
    baryon_theoretical_density = mwCallocA(num_bins_baryon, sizeof(real));
    dark_theoretical_density = mwCallocA(num_bins_dark, sizeof(real));
    
    if (baryon_theoretical_density == NULL || dark_theoretical_density == NULL) {
        fprintf(stderr, "Error: Failed to allocate memory for theoretical densities\n");
        if (baryon_theoretical_density) free(baryon_theoretical_density);
        if (dark_theoretical_density) free(dark_theoretical_density);
        result = 1;
        goto cleanup;
    }

    // Calculate theoretical density for baryon component
    for (int i = 0; i < num_bins_baryon; i++) {
        baryon_theoretical_density[i] = counts_per_bin(comp1, baryon_radius_array[i], 
                                         mass_per_particle_baryon, bin_width);
    }
    
    // Calculate theoretical density for dark matter component
    for (int i = 0; i < num_bins_dark; i++) {
        dark_theoretical_density[i] = counts_per_bin(comp2, dark_radius_array[i], 
                                       mass_per_particle_dark, bin_width);
    }

    // Print the theoretical densities
    printf("Baryon theoretical density: ");
    for (int i = 0; i < num_bins_baryon; i++) {
        printf("%.6f ", baryon_theoretical_density[i]);
    }
    printf("\n");

    printf("Dark matter theoretical density: ");
    for (int i = 0; i < num_bins_dark; i++) {
        printf("%.6f ", dark_theoretical_density[i]);
    }
    printf("\n");
    fflush(stdout);
    
    // Normalize the theoretical densities and add epsilon to avoid division by zero and log(0) in KL divergence calculation
    baryon_theoretical_probability = smooth_and_normalize_distribution(baryon_theoretical_density, num_bins_baryon);
    dark_theoretical_probability = smooth_and_normalize_distribution(dark_theoretical_density, num_bins_dark);
    
    if (baryon_theoretical_probability == NULL || dark_theoretical_probability == NULL) {
        fprintf(stderr, "Error: Failed to normalize theoretical densities\n");
        if (baryon_theoretical_density) free(baryon_theoretical_density);
        if (dark_theoretical_density) free(dark_theoretical_density);
        if (baryon_theoretical_probability) free(baryon_theoretical_probability);
        if (dark_theoretical_probability) free(dark_theoretical_probability);
        result = 1;
        goto cleanup;
    }

    // Print the theoretical probability densities
    printf("Baryon theoretical probability density: ");
    for (int i = 0; i < num_bins_baryon; i++) {
        printf("%.6f ", baryon_theoretical_probability[i]);
    }
    printf("\n");   

    printf("Dark matter theoretical probability density: ");
    for (int i = 0; i < num_bins_dark; i++) {
        printf("%.6f ", dark_theoretical_probability[i]);
    }
    printf("\n");
    fflush(stdout);

    // Run a simulation 
    printf("Running N-body simulation...\n");
    fflush(stdout);
    
    if (run_nbody(dwarf_params, input_lua_file) != 0) {
        fprintf(stderr, "Error: N-body simulation failed\n");
        fflush(stdout);
        result = 1;
        goto cleanup;
    }
    
    printf("N-body simulation completed successfully\n");
    fflush(stdout);

    // Calculate the KL divergence at the initial timestep
    const char* initial_output_filename = "0";
    printf("Checking for initial output file: %s\n", initial_output_filename);
    fflush(stdout);

    // Check if the initial output file exists
    if (access(initial_output_filename, F_OK) == -1) {
        fprintf(stderr, "Error: Initial output file '%s' does not exist\n", initial_output_filename);
        fflush(stdout);
        result = 1;
        goto cleanup;
    }

    // Read the initial output file
    particle_data = read_particle_file(initial_output_filename);
    if (!particle_data) {
        fprintf(stderr, "Error: Failed to read initial output file '%s'\n", initial_output_filename);
        fflush(stdout);
        result = 1;
        goto cleanup;
    }

    printf("Successfully read %zu particles from initial file\n", particle_data->count);
    fflush(stdout);
    
    // Validate particle count
    if (particle_data->count != (size_t)nbody) {
        fprintf(stderr, "Error: Expected %f particles but got %zu particles\n", 
               nbody, particle_data->count);
        free_particle_collection(particle_data);
        result = 1;
        goto cleanup;
    }

    // Calculate the initial density distribution for each component
    baryon_simulation_density = mwCallocA(num_bins_baryon, sizeof(real));
    dark_simulation_density = mwCallocA(num_bins_dark, sizeof(real));
    
    if (baryon_simulation_density == NULL || dark_simulation_density == NULL) {
        fprintf(stderr, "Error: Failed to allocate memory for initial simulation densities\n");
        if (baryon_simulation_density) free(baryon_simulation_density);
        if (dark_simulation_density) free(dark_simulation_density);
        free_particle_collection(particle_data);
        result = 1;
        goto cleanup;
    }

    // Initialize initial densities to zero
    for (int i = 0; i < num_bins_baryon; i++) {
        baryon_simulation_density[i] = 0.0;
    }
    for (int i = 0; i < num_bins_dark; i++) {
        dark_simulation_density[i] = 0.0;
    }

    // Calculate initial densities using histogram binning
    printf("Calculating initial densities for baryon particles...\n");
    fflush(stdout);
    
    for (int i = 0; i < (int)nbody_baryon && i < (int)particle_data->count; i++) {
        real radius = mw_sqrt(
            particle_data->particles[i].x * particle_data->particles[i].x + 
            particle_data->particles[i].y * particle_data->particles[i].y + 
            particle_data->particles[i].z * particle_data->particles[i].z
        );

        // Find the bin for this radius
        for (int bin = 0; bin < num_bins_baryon; bin++) {
            if (radius >= baryon_bin_edges[bin] && radius < baryon_bin_edges[bin + 1]) {
                baryon_simulation_density[bin] += 1.0;
                break;
            }
        }
    }

    printf("Calculating initial densities for dark matter particles...\n");
    fflush(stdout);
    
    for (int i = (int)nbody_baryon; i < (int)nbody && i < (int)particle_data->count; i++) {
        real radius = mw_sqrt(
            particle_data->particles[i].x * particle_data->particles[i].x + 
            particle_data->particles[i].y * particle_data->particles[i].y + 
            particle_data->particles[i].z * particle_data->particles[i].z
        );

        // Find the bin for this radius
        for (int bin = 0; bin < num_bins_dark; bin++) {
            if (radius >= dark_bin_edges[bin] && radius < dark_bin_edges[bin + 1]) {
                dark_simulation_density[bin] += 1.0;
                break;
            }
        }
    }

    // Print sample of initial densities
    printf("Initial baryon density distribution (first 5 values): ");
    for (int i = 0; i < num_bins_baryon && i < 5; i++) {
        printf("%.6f ", baryon_simulation_density[i]);
    }
    printf("...\n");
    
    printf("Initial dark matter density distribution (first 5 values): ");
    for (int i = 0; i < num_bins_dark && i < 5; i++) {
        printf("%.6f ", dark_simulation_density[i]);
    }
    printf("...\n");
    fflush(stdout);

    // Normalize the initial densities and add epsilon to avoid division by zero and log(0) in KL divergence calculation
    baryon_simulation_probability = smooth_and_normalize_distribution(baryon_simulation_density, num_bins_baryon);
    dark_simulation_probability = smooth_and_normalize_distribution(dark_simulation_density, num_bins_dark);
    
    if (baryon_simulation_probability == NULL || dark_simulation_probability == NULL) {
        fprintf(stderr, "Error: Failed to normalize initial simulation densities\n");
        if (baryon_simulation_density) free(baryon_simulation_density);
        if (dark_simulation_density) free(dark_simulation_density);
        if (baryon_simulation_probability) free(baryon_simulation_probability);
        if (dark_simulation_probability) free(dark_simulation_probability);
        free_particle_collection(particle_data);
        result = 1;
        goto cleanup;
    }

    // Print sample of normalized initial densities
    printf("Initial simulation baryon probability density distribution (first 5 values): ");
    for (int i = 0; i < num_bins_baryon && i < 5; i++) {
        printf("%.6f ", baryon_simulation_probability[i]);
    }
    printf("...\n");
    
    printf("Initial simulation dark matter probability density distribution (first 5 values): ");
    for (int i = 0; i < num_bins_dark && i < 5; i++) {
        printf("%.6f ", dark_simulation_probability[i]);
    }
    printf("...\n");
    fflush(stdout);

    // Kullback-Leibler divergence for each component for the initial timestep
    initial_kl_divergence_baryon = kl_divergence(baryon_simulation_probability, baryon_theoretical_probability, num_bins_baryon);
    initial_kl_divergence_dark = kl_divergence(dark_simulation_probability, dark_theoretical_probability, num_bins_dark);

    printf("Initial KL divergence for baryon component: %f\n", initial_kl_divergence_baryon);
    printf("Initial KL divergence for dark matter component: %f\n", initial_kl_divergence_dark);
    fflush(stdout);

    if (initial_kl_divergence_baryon < 0 || initial_kl_divergence_dark < 0) {
        fprintf(stderr, "Error: Negative KL divergence indicates calculation error\n");
        free_particle_collection(particle_data);
        result = 1;
        goto cleanup;
    }

    if (initial_kl_divergence_baryon > INITIAL_KL_THRESHOLD || initial_kl_divergence_dark > INITIAL_KL_THRESHOLD) {
        fprintf(stderr, "Error: Initial KL divergence is too high (> %f)\n", INITIAL_KL_THRESHOLD);
        fflush(stdout);
        free_particle_collection(particle_data);
        result = 1;
        goto cleanup;
    }

    // Free the particle collection
    free_particle_collection(particle_data);
    printf("Particle collection freed successfully\n");
    fflush(stdout);

    // Calculate the total number of timesteps in the simulation (using dwarf_param[0] which is 2.0 Gyr)
    int total_timesteps = (int)(atof(dwarf_params[0]) / timestep);
    if (total_timesteps <= 0) {
        fprintf(stderr, "Error: Invalid total timesteps: %d\n", total_timesteps);
        result = 1;
        goto cleanup;
    }
    printf("Total timesteps: %d\n", total_timesteps);
    fflush(stdout);

    // Calculate how many timesteps 0.1 Gyr is in the simulation
    int timesteps_0_1_Gyr = (int)(0.1 / timestep);
    if (timesteps_0_1_Gyr <= 0) {
        fprintf(stderr, "Error: Invalid timesteps per 0.1 Gyr: %d\n", timesteps_0_1_Gyr);
        result = 1;
        goto cleanup;
    }
    printf("Timesteps per 0.1 Gyr: %d\n", timesteps_0_1_Gyr);
    fflush(stdout);

    // Calculating first timestep to start from
    int first_timestep = timesteps_0_1_Gyr - 1;
    if (first_timestep < 0) {
        first_timestep = 0;  // Ensure it's not negative
    }
    printf("First timestep to check: %d\n", first_timestep);
    fflush(stdout);
    
    // Calculate the KL divergence at multiple timesteps
    for (int i = first_timestep; i < total_timesteps; i += timesteps_0_1_Gyr) {
        printf("\n--- Processing timestep %d ---\n", i);
        fflush(stdout);
        
        char output_filename[MAX_PATH_LENGTH];
        snprintf(output_filename, sizeof(output_filename), "%d", i);
        printf("Checking for output file: %s\n", output_filename);
        fflush(stdout);
        
        // Check if the output file exists
        if (access(output_filename, F_OK) == -1) {
            fprintf(stderr, "Error: Output file '%s' does not exist\n", output_filename);
            fflush(stdout);
            result = 1;
            goto cleanup;
        }
        
        printf("Output file exists, attempting to read...\n");
        fflush(stdout);
        
        particle_data = read_particle_file(output_filename);
        if (!particle_data) {
            fprintf(stderr, "Error: Failed to read particle file '%s'\n", output_filename);
            fflush(stdout);
            result = 1;
            goto cleanup;
        }

        printf("Successfully read %zu particles\n", particle_data->count);
        fflush(stdout);

        // Calculate the simulation density distribution for each component
        real* simulation_density_baryon = mwCallocA(num_bins_baryon, sizeof(real));
        real* simulation_density_dark = mwCallocA(num_bins_dark, sizeof(real));
        
        if (simulation_density_baryon == NULL || simulation_density_dark == NULL) {
            fprintf(stderr, "Error: Failed to allocate memory for simulation densities\n");
            if (simulation_density_baryon) free(simulation_density_baryon);
            if (simulation_density_dark) free(simulation_density_dark);
            free_particle_collection(particle_data);
            result = 1;
            goto cleanup;
        }

        // Initialize simulation densities to zero
        for (int j = 0; j < num_bins_baryon; j++) {
            simulation_density_baryon[j] = 0.0;
        }
        for (int j = 0; j < num_bins_dark; j++) {
            simulation_density_dark[j] = 0.0;
        }

        // Calculate simulation densities using histogram binning
        printf("Calculating simulation densities for baryon particles...\n");
        fflush(stdout);
        
        int baryon_particles_counted = 0;
        for (int j = 0; j < (int)nbody_baryon && j < (int)particle_data->count; j++) {
            real radius = mw_sqrt(
                particle_data->particles[j].x * particle_data->particles[j].x + 
                particle_data->particles[j].y * particle_data->particles[j].y + 
                particle_data->particles[j].z * particle_data->particles[j].z
            );

            // Find the bin for this radius
            for (int bin = 0; bin < num_bins_baryon; bin++) {
                if (radius >= baryon_bin_edges[bin] && radius < baryon_bin_edges[bin + 1]) {
                    simulation_density_baryon[bin] += 1.0;
                    baryon_particles_counted++;
                    break;
                }
            }
        }

        printf("Calculating simulation densities for dark matter particles...\n");
        fflush(stdout);
        
        int dark_particles_counted = 0;
        for (int j = (int)nbody_baryon; j < (int)nbody && j < (int)particle_data->count; j++) {
            real radius = mw_sqrt(
                particle_data->particles[j].x * particle_data->particles[j].x + 
                particle_data->particles[j].y * particle_data->particles[j].y + 
                particle_data->particles[j].z * particle_data->particles[j].z
            );

            // Find the bin for this radius
            for (int bin = 0; bin < num_bins_dark; bin++) {
                if (radius >= dark_bin_edges[bin] && radius < dark_bin_edges[bin + 1]) {
                    simulation_density_dark[bin] += 1.0;
                    dark_particles_counted++;
                    break;
                }
            }
        }
        
        printf("Particles counted: %d baryon, %d dark matter\n", 
               baryon_particles_counted, dark_particles_counted);
        fflush(stdout);

        // Print sample of simulation densities
        printf("Simulation baryon density distribution (first 5 values): ");
        for (int j = 0; j < num_bins_baryon && j < 5; j++) {
            printf("%.6f ", simulation_density_baryon[j]);
        }
        printf("...\n");
        
        printf("Simulation dark matter density distribution (first 5 values): ");
        for (int j = 0; j < num_bins_dark && j < 5; j++) {
            printf("%.6f ", simulation_density_dark[j]);
        }
        printf("...\n");
        fflush(stdout);

        // Normalize the simulation densities and add epsilon to avoid division by zero and log(0) in KL divergence calculation 
        real* simulation_probability_density_baryon = smooth_and_normalize_distribution(simulation_density_baryon, num_bins_baryon);
        real* simulation_probability_density_dark = smooth_and_normalize_distribution(simulation_density_dark, num_bins_dark);
        
        if (simulation_probability_density_baryon == NULL || simulation_probability_density_dark == NULL) {
            fprintf(stderr, "Error: Failed to normalize simulation densities\n");
            if (simulation_density_baryon) free(simulation_density_baryon);
            if (simulation_density_dark) free(simulation_density_dark);
            if (simulation_probability_density_baryon) free(simulation_probability_density_baryon);
            if (simulation_probability_density_dark) free(simulation_probability_density_dark);
            free_particle_collection(particle_data);
            result = 1;
            goto cleanup;
        }

        // Print sample of normalized simulation densities
        printf("Simulation baryon probability density distribution (first 5 values): ");
        for (int j = 0; j < num_bins_baryon && j < 5; j++) {
            printf("%.6f ", simulation_probability_density_baryon[j]);
        }
        printf("...\n");
        
        printf("Simulation dark matter probability density distribution (first 5 values): ");
        for (int j = 0; j < num_bins_dark && j < 5; j++) {
            printf("%.6f ", simulation_probability_density_dark[j]);
        }
        printf("...\n");
        fflush(stdout);

        // Kullback-Leibler divergence for each component
        real kl_divergence_baryon = kl_divergence(simulation_probability_density_baryon, baryon_theoretical_probability, num_bins_baryon);
        real kl_divergence_dark = kl_divergence(simulation_probability_density_dark, dark_theoretical_probability, num_bins_dark);

        printf("KL divergence for baryon component: %f\n", kl_divergence_baryon);
        printf("KL divergence for dark matter component: %f\n", kl_divergence_dark);
        printf("Difference from initial KL divergence (baryon): %f\n", mw_fabs(kl_divergence_baryon - initial_kl_divergence_baryon));
        printf("Difference from initial KL divergence (dark): %f\n", mw_fabs(kl_divergence_dark - initial_kl_divergence_dark));
        fflush(stdout);

        if (kl_divergence_baryon < 0 || kl_divergence_dark < 0) {
            fprintf(stderr, "Error: Negative KL divergence indicates calculation error\n");
            free(simulation_probability_density_baryon);
            free(simulation_probability_density_dark);
            free(simulation_density_baryon);
            free(simulation_density_dark);
            free_particle_collection(particle_data);
            result = 1;
            goto cleanup;
        }

        if (mw_fabs(kl_divergence_baryon - initial_kl_divergence_baryon) > KL_FLUCTUATION_THRESHOLD || 
            mw_fabs(kl_divergence_dark - initial_kl_divergence_dark) > KL_FLUCTUATION_THRESHOLD) {
            fprintf(stderr, "Error: KL divergence fluctuation is too high (> %f) showing instability\n", 
                   KL_FLUCTUATION_THRESHOLD);
            fflush(stdout);
            
            // Free allocated memory for this simulation iteration
            free(simulation_probability_density_baryon);
            free(simulation_probability_density_dark);
            free(simulation_density_baryon);
            free(simulation_density_dark);
            free_particle_collection(particle_data);
            result = 1;
            goto cleanup;
        }

        // Free allocated memory for this simulation iteration
        free(simulation_probability_density_baryon);
        free(simulation_probability_density_dark);
        free(simulation_density_baryon);
        free(simulation_density_dark);
        
        // Free data at the end of each iteration
        free_particle_collection(particle_data);
        printf("Particle collection freed successfully\n");
        fflush(stdout);
    }
    
    // Free memory for probability densities
    free(baryon_simulation_probability);
    baryon_simulation_probability = NULL;
    free(dark_simulation_probability);
    dark_simulation_probability = NULL;
    
    // Free memory at the end of function
    free(input_lua_file);
    input_lua_file = NULL;
    
    // Free additional memory that wasn't being freed before
    free(baryon_radius_array);
    baryon_radius_array = NULL;
    free(dark_radius_array);
    dark_radius_array = NULL;
    free(baryon_bin_edges);
    baryon_bin_edges = NULL;
    free(dark_bin_edges);
    dark_bin_edges = NULL;
    free(baryon_theoretical_density);
    baryon_theoretical_density = NULL;
    free(dark_theoretical_density);
    dark_theoretical_density = NULL;
    free(baryon_simulation_density);
    baryon_simulation_density = NULL;
    free(dark_simulation_density);
    dark_simulation_density = NULL;
    
    // If we get here, all KL divergence tests passed
    printf("All stability tests passed successfully!\n");
    fflush(stdout);
    
    // Success - return directly instead of falling through to cleanup
    result = 0;
    return result;
    
cleanup:
    // Centralized cleanup for all allocated memory
    cleanup_all_memory(
        input_lua_file, 
        baryon_radius_array, dark_radius_array,
        baryon_bin_edges, dark_bin_edges,
        baryon_theoretical_density, dark_theoretical_density,
        baryon_theoretical_probability, dark_theoretical_probability,
        baryon_simulation_density, dark_simulation_density,
        baryon_simulation_probability, dark_simulation_probability,
        particle_data
    );
    
    if (result == 0) {
        printf("Test completed successfully\n");
    } else {
        printf("Test failed\n");
    }
    fflush(stdout);
    
    return result;
}
