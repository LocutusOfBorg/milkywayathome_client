/* This program tests the stability of a 2-component dwarf galaxy.
* Dwarf galaxy types tested in this program:
* 1. Plummer-Plummer
* Stability is determined by Kullback-Leibler divergence calculation of the theoretical probability density distribution
* and the normalized density distribution generated by MilkyWay@home.  
* Since the distribution of baryons and dark matter are determined seperately, the program calculates the KL divergence for each component.
* If unstable, the generated density distribution tends to oscillate from looking stable to unstable.
* Because of this, the program calculates the KL divergence for each component at multiple time steps as to not accidentally conclude that an unstable system is stable.
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include "nbody.h"
#include "nbody_particle_data.h"
#include "nbody_dwarf_potential.h"
#include "nbody_types.h"
#include "nbody_lua.h"
#include "nbody_lua_types.h"

static real mass_enclosed_function(Dwarf *comp, real radius) {
    return 4 * M_PI * sqr(radius) * get_density(comp, radius);
}

static real counts_per_bin(Dwarf *comp, real radius, real mass_per_particle, real bin_width) {
    return mass_enclosed_function(comp, radius) * (1 / mass_per_particle) * bin_width;
}

static real kl_divergence(real *p, real *q, size_t size) {
    const real epsilon = 1e-10;
    real sum_p = 0.0;
    real sum_q = 0.0;
    real kl_div = 0.0;
    
    for (size_t i = 0; i < size; i++) {
        p[i] += epsilon;
        q[i] += epsilon;
        sum_p += p[i];
        sum_q += q[i];
    }
    
    for (size_t i = 0; i < size; i++) {
        p[i] /= sum_p;
        q[i] /= sum_q;
        kl_div += p[i] * mw_log(p[i] / q[i]);
    }
    
    return kl_div;
}

int run_nbody(const char** dwarf_params) {
    if (!dwarf_params) return 1;

    char command[1024];
    char cwd[1024];
    
    if (getcwd(cwd, sizeof(cwd)) == NULL) return 1;
    
    snprintf(command, sizeof(command), 
             "%s/../../bin/milkyway_nbody "
             "-f %s/../../../nbody/sample_workunits/test_env_lua/plummer_plummer.lua "
             "-o %s/output.out "
             "-z %s/output.hist "
             "-n 8 -b -w 1 -P -e 54231651 "
             "-i %s %s %s %s %s %s",
             cwd, cwd, cwd, cwd,
             dwarf_params[0], dwarf_params[1], dwarf_params[2], 
             dwarf_params[3], dwarf_params[4], dwarf_params[5]);
    
    return system(command);
}

// Function to read parameters from Lua file
int read_lua_parameters(const char* input_file, const char** dwarf_params, real* nbody, real* nbody_baryon, Dwarf** comp1, Dwarf** comp2) {
    printf("Opening Lua state with file: %s\n", input_file);
    
    NBodyFlags nbf = {
        .inputFile = input_file,
        .debugLuaLibs = TRUE,  // Enable debug output
        .forwardedArgs = dwarf_params,
        .numForwardedArgs = 6
    };

    lua_State* L = nbOpenLuaStateWithScript(&nbf, NULL);
    if (!L) {
        printf("Failed to open Lua state\n");
        return 1;
    }

    // Get the makeBodies function
    lua_getglobal(L, "makeBodies");
    if (!lua_isfunction(L, -1)) {
        printf("makeBodies function not found in Lua script\n");
        lua_close(L);
        return 1;
    }

    // Get the makeContext function
    lua_getglobal(L, "makeContext");
    if (!lua_isfunction(L, -1)) {
        printf("makeContext function not found in Lua script\n");
        lua_close(L);
        return 1;
    }

    // Call makeContext
    printf("Calling makeContext...\n");
    if (lua_pcall(L, 0, 1, 0) != 0) {
        printf("Error calling makeContext: %s\n", lua_tostring(L, -1));
        lua_close(L);
        return 1;
    }

    // Push nil for potential
    lua_pushnil(L);

    // Call makeBodies
    printf("Calling makeBodies...\n");
    if (lua_pcall(L, 2, 1, 0) != 0) {
        printf("Error calling makeBodies: %s\n", lua_tostring(L, -1));
        lua_close(L);
        return 1;
    }

    // Get the number of bodies
    lua_getglobal(L, "totalBodies");
    if (!lua_isnumber(L, -1)) {
        printf("totalBodies is not a number\n");
        lua_close(L);
        return 1;
    }
    *nbody = lua_tonumber(L, -1);
    lua_pop(L, 1);

    lua_getglobal(L, "totalLightBodies");
    if (!lua_isnumber(L, -1)) {
        printf("totalLightBodies is not a number\n");
        lua_close(L);
        return 1;
    }
    *nbody_baryon = lua_tonumber(L, -1);
    lua_pop(L, 1);

    // Get the model object
    if (!lua_istable(L, -1)) {
        printf("makeBodies did not return a table\n");
        lua_close(L);
        return 1;
    }

    // Get the model's components
    lua_getfield(L, -1, "comp1");
    if (!lua_isuserdata(L, -1)) {
        printf("comp1 is not a userdata\n");
        lua_close(L);
        return 1;
    }
    *comp1 = (Dwarf*)mw_checknamedudata(L, -1, DWARF_TYPE);
    lua_pop(L, 1);

    lua_getfield(L, -1, "comp2");
    if (!lua_isuserdata(L, -1)) {
        printf("comp2 is not a userdata\n");
        lua_close(L);
        return 1;
    }
    *comp2 = (Dwarf*)mw_checknamedudata(L, -1, DWARF_TYPE);
    lua_pop(L, 1);

    printf("Successfully read all Lua parameters\n");
    lua_close(L);
    return 0;
}

int main()
{   
    printf("Starting stability test...\n");
    
    const char* dwarf_params[] = {
        "0.1",       // ft
        "0.0",       // time_ratio
        "0.181216",  // rscale_baryon
        "0.182799",  // radius_ratio
        "1.22251",   // baryon mass
        "0.0126171"  // mass ratio
    };

    char cwd[1024];
    if (getcwd(cwd, sizeof(cwd)) == NULL) {
        printf("Failed to get current working directory\n");
        return 1;
    }

    char input_file[1024];
    snprintf(input_file, sizeof(input_file), "%s/../../../nbody/sample_workunits/test_env_lua/plummer_plummer.lua", cwd);
    printf("Input file path: %s\n", input_file);

    if (access(input_file, F_OK) == -1) {
        printf("Input file does not exist: %s\n", input_file);
        return 1;
    }

    // First, read the parameters from the Lua file
    real nbody, nbody_baryon;
    Dwarf *comp1, *comp2;
    printf("Reading Lua parameters...\n");
    if (read_lua_parameters(input_file, dwarf_params, &nbody, &nbody_baryon, &comp1, &comp2) != 0) {
        printf("Failed to read Lua parameters\n");
        return 1;
    }

    printf("Read parameters from Lua file:\n");
    printf("nbody: %f\n", nbody);
    printf("nbody_baryon: %f\n", nbody_baryon);
    printf("comp1 mass: %f\n", comp1->mass);
    printf("comp2 mass: %f\n", comp2->mass);

    // Now run the simulation separately
    printf("Running N-body simulation...\n");
    if (run_nbody(dwarf_params) != 0) {
        printf("N-body simulation failed\n");
        return 1;
    }

    const char *input_filename = "output.out";
    printf("Reading particle file: %s\n", input_filename);
    ParticleCollection *data = read_particle_file(input_filename);

    if (data) {
        printf("Successfully read particle file\n");
        free_particle_collection(data);
    } else {
        printf("Failed to read particle file\n");
        return 1;
    }

    printf("Test completed successfully\n");
    return 0;
}